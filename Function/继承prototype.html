<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
/*让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：
{a: 1, b: 2}
o 的原型 o.[[Prototype]]有属性 b 和 c：
{b: 3, c: 4}
最后, o.[[Prototype]].[[Prototype]] 是 null.
这就是原型链的末尾，即 null，
根据定义，null 没有[[Prototype]].
综上，整个原型链如下: 
{a:1, b:2} ---> {b:3, c:4} ---> null

console.log(o.a); // 1
a是o的自身属性吗？是的，该属性的值为1

console.log(o.b); // 2
b是o的自身属性吗？是的，该属性的值为2
o.[[Prototype]]上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".

console.log(o.c); // 4
c是o的自身属性吗？不是，那看看o.[[Prototype]]上有没有.
c是o.[[Prototype]]的自身属性吗？是的,该属性的值为4

console.log(o.d); // undefined
d是o的自身属性吗？不是,那看看o.[[Prototype]]上有没有.
d是o.[[Prototype]]的自身属性吗？不是，那看看o.[[Prototype]].[[Prototype]]上有没有.
o.[[Prototype]].[[Prototype]]为null，停止搜索，
没有d属性，返回undefined*/


// 普通语法创建对象

 // hasOwnPropetry() 函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。
	var  o = {a: 1};
	 //alert(o.hasOwnProperty('a'));true;
	 // hasOwnProperty 是Object.prototype的自身属性。
	// Object.prototype的原型为null。
	// 原型链如下:
	
	
	var a = ["yo", "whadup", "?"];

		// 数组都继承于Array.prototype 
		// (indexOf, forEach等方法都是从它继承而来).
		// 原型链如下:
		// a ---> Array.prototype ---> Object.prototype ---> null

		function f(){
		  return 2;
		}

		// 函数都继承于Function.prototype
		// (call, bind等方法都是从它继承而来):
		// f ---> Function.prototype ---> Object.prototype ---> null，

//构造器创建对象
		function Graph() {
			this.vertexes = [];
			this.edags = [];
		}

		Graph.prototype = {
			addVertex: function(v) {
				this.vertexes.push(v);
			}
		};
		var g = new Graph();
		// alert(g.vertexes);空
		// alert(g.edags)空
		// g是生成的对象,他的自身属性有'vertices'和'edges'.
		
		g.addVertex("a")//
		// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.
		g.vertexes//a

// Object.create 创建对象

	var b = {a : 1};
	var c = Object.create(b);
	alert(c.a)//1 继承自b

	var d = Object.create(c);
	alert(d.a)//1 d ----> b -----> Object.prototype ---> null;

	var e = Object.create(null);
	//e ---> null;
	alert(Object.hasOwnProperty("e"))//false 因为d没有继承Object.prototype


	"use strict"
</script>
</body>
</html>